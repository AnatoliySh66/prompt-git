### Создание Git проекта.

#### Сделать папку репозиторием — git init
```
$ cd ~/dev/first-project # перешли в нужную папку
$ git **init** # создали репозиторий
```

#### «Разгитить» папку, если что-то пошло не так:
```
$ rm -rf .git
```

##### Разберём подробнее, что такое -rf:


ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым; <br>
ключ -f (от англ. force — «заставить») избавит вас от вопросов вроде <br>
«Вы точно хотите удалить этот файл? А этот? И этот тоже?». <br>

##### Проверить состояние репозитория:

```
$ git status
```

##### Подготовить файлы к сохранению — git add


Мы хотим отслеживать состояние созданных(изм.) файлов, поэтому можем использовать команду: <br>

```
$ git add --all
$ git add todo.txt
$ git add . # добавить всю текущую папку
```

##### Выполнить коммит — git commit


Сделать коммит можно командой git commit c ключом -m (от англ. message — «сообщение»), <br>
который присваивает коммиту сообщение:

```
$ git commit -m 'Мой первый коммит!'
```

##### Просмотреть историю коммитов:

```
$ git log
```

##### Привязать удалённый репозиторий к локальному — git remote add

```
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/имя_проекта
git branch -M main
git push -u origin main #Первая отправка. Вместо main может быть master
```

##### Убедиться, что репозитории связаны, — git remote -v

##### Отправить изменения на удалённый репозиторий — git push

---

#### Хеш — основной идентификатор коммита

Git хранит таблицу соответствий **хеш → информация о коммите.** <br>
Если вы знаете хеш, вы можете узнать всё остальное: <br>
 - автора и дату коммита и содержимое закоммиченных файлов. <br>
Можно сказать, что **хеш — основной идентификатор коммита.** <br>
Все хеши и таблицу **хеш → информация о коммите** Git сохраняет в служебные файлы. <br>
Они находятся в скрытой папке **.git** в репозитории проекта.

---

#### Элементы описания коммита

После вызова **git log** появляется список коммитов: <br>
 - строка из цифр и латинских букв после слова commit — это хеш коммита;
 - Author — имя автора и его электронная почта;
 - Date — дата и время создания коммита;
 - в конце находится сообщение коммита. 

##### Получить сокращённый лог — git log --oneline

Сокращённый лог полезен, если в репозитории уже много коммитов. В этом случае можно быстро найти нужный по описанию.
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

---

### Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. 
Он указывает на коммит, который сделан последним (то есть на самый новый).
В этом можно убедиться с помощью терминала. Перейдите в папку .git командой cd. 
Посмотрите содержимое файла HEAD командой cat.

```
$ pwd # посмотрели, где мы
/Users/user/dev/first-project
$ cd .git/
$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка
```

Внутри HEAD — ссылка на служебный файл: <br> 
refs/heads/master (или refs/heads/main). <br> 
Если заглянуть в этот файл, можно увидеть хеш последнего коммита. <br>

```
$ cat refs/heads/master # взяли ссылку из файла HEAD <br>
внутри хеш: e007f5035f113f9abca78fe2149c593959da5eb7
$ git log
 #сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел
```

Когда вы делаете коммит, Git обновляет refs/heads/master <br>
— записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, <br>
так как ссылается на refs/heads/master.
При работе с Git указатель HEAD используется довольно часто.
Многие команды Git принимают в качестве параметра хеш коммита.
Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD 
— Git поймёт, что вы имели в виду последний коммит.

---

#### Статусы untracked/tracked, staged и modified
Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

 - untracked (англ. «неотслеживаемый»)

Новые файлы в Git-репозитории помечаются как untracked. 
Git «видит», что такой файл существует, но не следит за изменениями в нём. 

 - staged (англ. «подготовленный»)

После выполнения команды git add файл попадает в staging area, то есть в список файлов, которые войдут в коммит.
В этот момент файл находится в состоянии staged.

 - tracked (англ. «отслеживаемый»)

Состояние tracked — это противоположность untracked. В него попадают файлы, в которых Git так или иначе отслеживает изменения.

 - modified (англ. «изменённый»)

Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия.
Например, файл был закоммичен и после этого изменён.

---

#### Оформление сообщений к коммитам

То, как написаны сообщения коммитов, тоже может подчиняться определённым правилам.
Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями. <br>

Например, в выводе команды git log --oneline умещается максимум 72 первых символа сообщения,
поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов». <br>

В Git есть сообщение — то, что передаётся после параметра -m. <br>

Есть общие рекомендации по тому, как правильно составить сообщение.
Оно должно быть: 
 - относительно коротким, чтобы его было легко прочитать; 
 - информативным.

